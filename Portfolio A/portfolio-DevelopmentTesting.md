Development Testing
===================================

![alt text](https://github.com/kamenPB/Green-Credentials/blob/master/Portfolio%20A/PNG/Architecture_diagram.jpg "Architecture Diagram")

Due to the passive nature of the "front-end" of our software being a TV display for the passers-by in Cabot Circus, most of our testing will focus on the back-end, where the Cabot staff enter data. To thoroughly test this, a unit-testing framework JUnit will be used. For the test strategy of our software, we will individually test the components shown in the simple architecture diagram above. For example, the Water object class will have to be tested with unit tests to guarantee it can handle different data inputs, whether that be edge case values, inappropriate input, or other exceptional sources from the spreadsheets.

Since it will be difficult to test our "front-end" in house, we will have to look for opinion based feedback from both the Cabot team and customers. This can be done by having multiple designs of different chart types and colours for each component, and presenting them for comparison. By doing this, we can get more certainty to how our designs are perceived by a relevant audience. 
 
Past exception handling, the main source of errors will be human error in the spreadsheet being input to our system. To this end, we can provide in our User Manual suitable guidelines for what the software expects and provide a downloadable template spreadsheet for the data entry staff. This will help avoid issues which may arise if their original spreadsheet is lost and can help increase the system's maintainability if a different staff member unfamiliar with the system is placed in charge sometime in the future. We can also implement type checks throughout our program so that if, for example, someone inputs a character where we are expecting a numerical value, it will alert us before the data is displayed. In the case of falsely inputted data of the right type (say a 70% decrease instead of a 7% decrease) it will be harder for us to test. We may have to set soft limits for the values so that if the data exceeds said values, the person inputting the data will have to confirm its validity by entering a previously agreen on character (such as True) in a new column.
 
We will use a mixture of both integration testing and unit testing. Unit tests will be vital whilst building up the foundation of the code to ensure that each individual method used, such as finding the last time a certain category of data has been udpated, works as we will be dealing with these types of problems individually. The integration tests become useful when combining our work to see if there are any unintended interactions between parts that may cause a problem, the structure of our project is very linear, the data starts from the user and is passed through multiple stages that only interact with the phase before or after it, so the design is very strict, straying from this would not work at all because of how the stages are linked.
 
On the subject of future-proofing, there are other such issues where testability may become difficult as time passes. For instance, if Cabot Circus decides to abandon their solar panels, it may interfere with what the software expects. To this end, we may have to introduce mechanisms through which certain data categories can be disabled. For example, that would be the removal of the solar-powered electricity generated by the shopping centre.
